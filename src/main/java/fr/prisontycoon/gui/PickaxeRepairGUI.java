package fr.prisontycoon.gui;

import fr.prisontycoon.PrisonTycoon;
import fr.prisontycoon.data.PlayerData;
import fr.prisontycoon.enchantments.CustomEnchantment;
import fr.prisontycoon.utils.NumberFormatter;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * CORRIG√â : Menu de r√©paration avec nouveau syst√®me de co√ªt exponentiel
 * NOUVEAU : Tous les boutons r√©parent le maximum possible selon les tokens
 * CORRIG√â : Fix du bug de durabilit√© √† 2030
 */
public class PickaxeRepairGUI {

    // Slots pour les boutons de r√©paration (tous identiques maintenant)
    private static final int[] REPAIR_BUTTON_SLOTS = {11, 12, 13, 14, 15};
    private static final int PICKAXE_INFO_SLOT = 4;
    private static final int BACK_BUTTON_SLOT = 18;
    private static final double COST_BASE_FACTOR = 0.0001; // 0.01% de l'investissement total
    private static final double DAMAGE_EXPONENT = 2.5;     // Exposant de la courbe de co√ªt
    private final PrisonTycoon plugin;

    public PickaxeRepairGUI(PrisonTycoon plugin) {
        this.plugin = plugin;
    }

    /**
     * G√®re les clics dans le menu de r√©paration
     */
    public void handleRepairMenuClick(Player player, int slot, ItemStack clickedItem) {
        // Clic sur le bouton retour
        if (slot == BACK_BUTTON_SLOT) {
            player.playSound(player.getLocation(), Sound.UI_BUTTON_CLICK, 1.0f, 1.0f);
            plugin.getMainMenuGUI().openEnchantmentMenu(player);
            return;
        }

        // V√©rifie si le joueur a cliqu√© sur un bouton de r√©paration
        for (int repairSlot : REPAIR_BUTTON_SLOTS) {
            if (slot == repairSlot) {
                // Emp√™che l'action si c'est un bouton d√©sactiv√©
                if (clickedItem.getType() == Material.BARRIER || clickedItem.getType() == Material.DIAMOND) {
                    player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 1.0f, 1.0f);
                    return;
                }

                // C'est un clic valide sur un bouton de r√©paration
                handleMaxRepair(player);
                return;
            }
        }
    }

    /**
     * Ouvre le menu de r√©paration de la pioche
     */
    public void openRepairGUI(Player player) {
        Inventory gui = Bukkit.createInventory(null, 27, "¬ßcüî® ¬ßlR√©paration de Pioche ¬ßcüî®");

        // Remplissage d√©coratif
        fillBorders(gui);

        // Informations de la pioche
        gui.setItem(PICKAXE_INFO_SLOT, createPickaxeInfoItem(player));

        // Boutons de r√©paration (tous identiques)
        createRepairButtons(gui, player);

        // Bouton retour
        gui.setItem(BACK_BUTTON_SLOT, createBackButton());

        plugin.getGUIManager().registerOpenGUI(player, GUIType.PICKAXE_REPAIR, gui);
        player.openInventory(gui);
    }

    /**
     * NOUVEAU : Cr√©e les boutons de r√©paration (tous identiques)
     */
    private void createRepairButtons(Inventory gui, Player player) {
        ItemStack pickaxe = plugin.getPickaxeManager().findPlayerPickaxe(player);
        if (pickaxe == null) {
            // Si pas de pioche, d√©sactive tous les boutons
            for (int slot : REPAIR_BUTTON_SLOTS) {
                gui.setItem(slot, createDisabledButton());
            }
            return;
        }

        // CORRIG√â : Calcul pr√©cis de l'√©tat actuel
        short currentDurability = pickaxe.getDurability();
        short maxDurability = pickaxe.getType().getMaxDurability();

        // CORRIG√â : Si d√©j√† √† 100% (durabilit√© = 0), d√©sactive la r√©paration
        if (currentDurability == 0) {
            for (int slot : REPAIR_BUTTON_SLOTS) {
                gui.setItem(slot, createFullyRepairedButton());
            }
            return;
        }

        PlayerData playerData = plugin.getPlayerDataManager().getPlayerData(player.getUniqueId());
        long playerTokens = playerData.getTokens();

        // NOUVEAU : Calcul de la r√©paration maximale possible
        MaxRepairResult maxRepair = calculateMaxRepair(currentDurability, maxDurability, playerTokens, playerData);

        // Cr√©e tous les boutons identiques
        for (int slot : REPAIR_BUTTON_SLOTS) {
            ItemStack button = createMaxRepairButton(maxRepair, playerTokens);
            gui.setItem(slot, button);
        }
    }

    private long calculateCostToRepairRange(long totalInvested, short maxDurability, int fromDurability, int toDurability) {
        if (fromDurability <= toDurability) {
            return 0;
        }

        // Constante C de la formule f(x) = C * x^k
        double constant = (totalInvested * COST_BASE_FACTOR) / Math.pow(maxDurability, DAMAGE_EXPONENT);

        // Nouvel exposant k+1
        double newExponent = DAMAGE_EXPONENT + 1.0;

        // Calcul de l'int√©grale d√©finie : F(from) - F(to)
        double integralFrom = Math.pow(fromDurability, newExponent) / newExponent;
        double integralTo = Math.pow(toDurability, newExponent) / newExponent;

        return Math.max(1, (long) (constant * (integralFrom - integralTo)));
    }

    /**
     * CORRIG√â : Calcule la r√©paration maximale en additionnant le co√ªt de chaque point.
     * Cette m√©thode est juste et emp√™che de "tricher" en r√©parant en plusieurs fois.
     */
    private MaxRepairResult calculateMaxRepair(short currentDurability, short maxDurability, long playerTokens, PlayerData playerData) {
        if (currentDurability == 0) {
            return new MaxRepairResult(0, 0, 0, 100.0);
        }

        long totalInvested = calculateTotalInvestedTokens(playerData);

        // Bornes pour la recherche dichotomique
        int low = 0; // 0 points r√©par√©s
        int high = currentDurability; // Tous les points r√©par√©s
        int bestRepairAmount = 0;

        // La recherche s'arr√™te apr√®s ~11-12 it√©rations au lieu de ~1500
        while (low <= high) {
            int mid = low + (high - low) / 2; // Le nombre de points qu'on essaie de r√©parer
            if (mid == 0) {
                low = 1;
                continue;
            }

            // Durabilit√© finale si on r√©pare 'mid' points
            int finalDurability = currentDurability - mid;

            // On utilise la formule O(1) pour calculer le co√ªt
            long cost = calculateCostToRepairRange(totalInvested, maxDurability, currentDurability, finalDurability);

            if (cost <= playerTokens) {
                // On peut se le permettre. On stocke ce r√©sultat et on essaie d'en r√©parer plus.
                bestRepairAmount = mid;
                low = mid + 1;
            } else {
                // Trop cher. On cherche dans la moiti√© inf√©rieure.
                high = mid - 1;
            }
        }

        if (bestRepairAmount == 0) {
            return new MaxRepairResult(0, 0, 0, ((double) (maxDurability - currentDurability) / maxDurability) * 100);
        }

        long finalCost = calculateCostToRepairRange(totalInvested, maxDurability, currentDurability, currentDurability - bestRepairAmount);

        // Calcul des pourcentages pour l'affichage
        double currentHealthPercent = ((double) (maxDurability - currentDurability) / maxDurability) * 100;
        double newDurability = currentDurability - bestRepairAmount;
        double newHealthPercent = ((maxDurability - newDurability) / maxDurability) * 100;
        double repairPercent = newHealthPercent - currentHealthPercent;

        return new MaxRepairResult(bestRepairAmount, finalCost, repairPercent, newHealthPercent);
    }

    /**
     * NOUVEAU : Cr√©e un bouton de r√©paration maximale
     */
    private ItemStack createMaxRepairButton(MaxRepairResult maxRepair, long playerTokens) {
        ItemStack item = new ItemStack(Material.EMERALD);
        ItemMeta meta = item.getItemMeta();

        meta.setDisplayName("¬ßa‚ö° ¬ßlR√âPARATION MAXIMALE");

        List<String> lore = new ArrayList<>();
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        if (maxRepair.repairPoints > 0) {
            lore.add("¬ßeüìä ¬ßlD√âTAILS DE LA R√âPARATION");
            lore.add("¬ß7‚îÇ ¬ßePoints de r√©paration: ¬ßa+" + maxRepair.repairPoints);
            lore.add("¬ß7‚îÇ ¬ßeR√©paration effective: ¬ßa+" + String.format("%.1f%%", maxRepair.repairPercent));
            lore.add("¬ß7‚îÇ ¬ße√âtat final: " + getDurabilityColor(maxRepair.finalHealthPercent) +
                    String.format("%.1f%%", maxRepair.finalHealthPercent));
            lore.add("¬ß7‚îî");
            lore.add("");

            lore.add("¬ß6üí∞ ¬ßlCO√õT");
            lore.add("¬ß7‚îÇ ¬ßeCo√ªt: ¬ß6" + NumberFormatter.format(maxRepair.cost) + " tokens");

            if (playerTokens >= maxRepair.cost) {
                lore.add("¬ß7‚îÇ ¬ßaVous pouvez effectuer cette r√©paration!");
                lore.add("¬ß7‚îî");
                lore.add("");
                lore.add("¬ßa‚úÖ ¬ßlCLIQUEZ POUR R√âPARER");
            } else {
                lore.add("¬ß7‚îÇ ¬ßcTokens insuffisants!");
                lore.add("¬ß7‚îÇ ¬ßcIl vous manque: ¬ß4" + NumberFormatter.format(maxRepair.cost - playerTokens) + " tokens");
                lore.add("¬ß7‚îî");
                lore.add("");
                lore.add("¬ßc‚ùå ¬ßlTOKENS INSUFFISANTS");
                item.setType(Material.BARRIER);
            }
        } else {
            lore.add("¬ßc‚ùå ¬ßlAUCUNE R√âPARATION POSSIBLE");
            lore.add("¬ß7‚îÇ ¬ßcTokens insuffisants pour r√©parer");
            lore.add("¬ß7‚îÇ ¬ßem√™me un seul point de durabilit√©.");
            lore.add("¬ß7‚îî");
            item.setType(Material.BARRIER);
        }

        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);
        item.setItemMeta(meta);

        return item;
    }

    /**
     * NOUVEAU : Effectue la r√©paration maximale possible
     */
    public void handleMaxRepair(Player player) {
        PlayerData playerData = plugin.getPlayerDataManager().getPlayerData(player.getUniqueId());

        // V√©rification des conditions de base
        ItemStack pickaxe = plugin.getPickaxeManager().findPlayerPickaxe(player);
        if (pickaxe == null) {
            player.sendActionBar("¬ßc‚ùå Pioche l√©gendaire introuvable!");
            return;
        }

        short currentDurability = pickaxe.getDurability();
        short maxDurability = pickaxe.getType().getMaxDurability();

        // CORRIG√â : Emp√™che la r√©paration si d√©j√† √† 100%
        if (currentDurability == 0) {
            player.sendActionBar("¬ße‚ö†Ô∏è Votre pioche est d√©j√† enti√®rement r√©par√©e!");
            player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 1.0f, 1.0f);
            return;
        }

        // Calcul de la r√©paration maximale possible
        MaxRepairResult maxRepair = calculateMaxRepair(currentDurability, maxDurability, playerData.getTokens(), playerData);

        if (maxRepair.repairPoints == 0) {
            player.sendActionBar("¬ßc‚ùå Tokens insuffisants pour toute r√©paration!");
            player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 1.0f, 1.0f);
            return;
        }

        // V√©rification finale des tokens (s√©curit√©)
        if (playerData.getTokens() < maxRepair.cost) {
            player.sendActionBar("¬ßc‚ùå Erreur: tokens insuffisants!");
            player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 1.0f, 1.0f);
            return;
        }

        // Application de la r√©paration
        int newDurability = Math.max(0, currentDurability - maxRepair.repairPoints);
        pickaxe.setDurability((short) newDurability);

        // D√©duction des tokens
        playerData.removeTokens(maxRepair.cost);

        // Mise √† jour de la pioche
        plugin.getPickaxeManager().deactivateBrokenPickaxeMode(player);
        player.removeMetadata("durability_notif_broken", plugin);
        plugin.getPickaxeManager().updatePlayerPickaxe(player);
        plugin.getPickaxeManager().updateMobilityEffects(player);

        // Reset les notifications de durabilit√©
        player.removeMetadata("durability_notif_25", plugin);
        player.removeMetadata("durability_notif_10", plugin);

        // Messages de succ√®s
        player.sendActionBar("¬ßa‚úÖ Pioche r√©par√©e: +" + String.format("%.1f%%", maxRepair.repairPercent) +
                " (-" + NumberFormatter.format(maxRepair.cost) + " tokens)");

        player.playSound(player.getLocation(), Sound.BLOCK_ANVIL_USE, 1.0f, 1.2f);
        plugin.getActionBarTask().updateActionBarStatus();

        // Mise √† jour du menu
        plugin.getServer().getScheduler().runTaskLater(plugin, () -> {
            if (player.getOpenInventory().getTitle().equals("¬ßcüî® ¬ßlR√©paration de Pioche ¬ßcüî®")) {
                createRepairButtons(player.getOpenInventory().getTopInventory(), player);
                player.getOpenInventory().getTopInventory().setItem(PICKAXE_INFO_SLOT, createPickaxeInfoItem(player));
            }
        }, 1L);

        plugin.getPluginLogger().info("R√©paration maximale effectu√©e pour " + player.getName() +
                ": +" + maxRepair.repairPoints + " points (+" + String.format("%.1f%%", maxRepair.repairPercent) +
                ") pour " + NumberFormatter.format(maxRepair.cost) + " tokens");
    }

    private void fillBorders(Inventory gui) {
        ItemStack borderItem = new ItemStack(Material.GRAY_STAINED_GLASS_PANE);
        ItemMeta meta = borderItem.getItemMeta();
        meta.setDisplayName(" ");
        borderItem.setItemMeta(meta);

        // Remplir les bordures
        for (int i = 0; i < 9; i++) {
            gui.setItem(i, borderItem);
            gui.setItem(i + 18, borderItem);
        }

        for (int i = 9; i < 18; i += 9) {
            gui.setItem(i, borderItem);
            gui.setItem(i + 8, borderItem);
        }
    }

    private ItemStack createBackButton() {
        ItemStack item = new ItemStack(Material.ARROW);
        ItemMeta meta = item.getItemMeta();
        meta.setDisplayName("¬ßc‚¨Ö ¬ßlRetour au menu principal");
        item.setItemMeta(meta);
        return item;
    }

    private ItemStack createDisabledButton() {
        ItemStack item = new ItemStack(Material.BARRIER);
        ItemMeta meta = item.getItemMeta();
        meta.setDisplayName("¬ßc‚ùå ¬ßlR√âPARATION INDISPONIBLE");
        List<String> lore = new ArrayList<>();
        lore.add("¬ßcPioche l√©gendaire introuvable!");
        lore.add("¬ß7Assurez-vous qu'elle est dans votre inventaire.");
        meta.setLore(lore);
        item.setItemMeta(meta);
        return item;
    }

    private ItemStack createFullyRepairedButton() {
        ItemStack item = new ItemStack(Material.DIAMOND);
        ItemMeta meta = item.getItemMeta();

        meta.setDisplayName("¬ßa‚úÖ ¬ßlPIOCHE ENTI√àREMENT R√âPAR√âE");

        List<String> lore = new ArrayList<>();
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
        lore.add("¬ßaüìä ¬ßl√âTAT PARFAIT");
        lore.add("¬ß7‚îÇ ¬ßeDurabilit√©: ¬ßa100.0%");
        lore.add("¬ß7‚îÇ ¬ßeVotre pioche est en parfait √©tat!");
        lore.add("¬ß7‚îî");
        lore.add("");
        lore.add("¬ße‚ö†Ô∏è ¬ßlR√âPARATION IMPOSSIBLE");
        lore.add("¬ß7‚îÇ ¬ß7Votre pioche n'a pas besoin de r√©paration.");
        lore.add("¬ß7‚îî");
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);
        item.setItemMeta(meta);

        return item;
    }

    private String getDurabilityColor(double healthPercent) {
        if (healthPercent >= 90) return "¬ßa";
        if (healthPercent >= 70) return "¬ße";
        if (healthPercent >= 40) return "¬ß6";
        if (healthPercent >= 20) return "¬ßc";
        return "¬ß4";
    }

    private long calculateTotalInvestedTokens(PlayerData playerData) {
        long total = 0;
        Map<String, Integer> enchantments = playerData.getEnchantmentLevels();

        for (Map.Entry<String, Integer> entry : enchantments.entrySet()) {
            CustomEnchantment enchant = plugin.getEnchantmentManager().getEnchantment(entry.getKey());
            if (enchant != null) {
                int level = entry.getValue();
                for (int i = 1; i <= level; i++) {
                    total += enchant.getUpgradeCost(i);
                }
            }
        }

        return total;
    }

    /**
     * CORRIG√â : Informations de la pioche avec calcul de durabilit√© pr√©cis
     */
    private ItemStack createPickaxeInfoItem(Player player) {
        ItemStack item = new ItemStack(Material.DIAMOND_PICKAXE);
        ItemMeta meta = item.getItemMeta();

        meta.setDisplayName("¬ß6‚õèÔ∏è ¬ßlINFORMATIONS DE LA PIOCHE");

        List<String> lore = new ArrayList<>();
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        ItemStack pickaxe = plugin.getPickaxeManager().findPlayerPickaxe(player);
        PlayerData playerData = plugin.getPlayerDataManager().getPlayerData(player.getUniqueId());

        if (pickaxe != null) {
            short currentDurability = pickaxe.getDurability();
            short maxDurability = pickaxe.getType().getMaxDurability();

            // CORRIG√â : Calcul pr√©cis du pourcentage de sant√©
            double healthPercent = ((double) (maxDurability - currentDurability) / maxDurability) * 100;

            lore.add("¬ße‚õèÔ∏è ¬ßl√âTAT ACTUEL");
            lore.add("¬ß7‚îÇ ¬ßeDurabilit√©: " + getDurabilityColor(healthPercent) + String.format("%.1f%%", healthPercent));
            lore.add("¬ß7‚îÇ ¬ßePoints: ¬ß6" + (maxDurability - currentDurability) + "¬ß7/¬ß6" + maxDurability);
            lore.add("¬ß7‚îÇ ¬ßeEndommagement: ¬ßc" + currentDurability + " points");

            if (currentDurability == 0) {
                lore.add("¬ß7‚îÇ ¬ßa‚úì Pioche en parfait √©tat!");
            } else if (healthPercent < 15) {
                lore.add("¬ß7‚îÇ ¬ßc‚ö†Ô∏è R√©paration critique recommand√©e!");
            } else if (healthPercent < 30) {
                lore.add("¬ß7‚îÇ ¬ße‚ö†Ô∏è R√©paration recommand√©e");
            } else {
                lore.add("¬ß7‚îÇ ¬ßa‚úì En bon √©tat");
            }

            lore.add("¬ß7‚îî");
            lore.add("");

            // Informations sur le nouveau syst√®me de co√ªt
            long totalInvested = calculateTotalInvestedTokens(playerData);
            lore.add("¬ß6üí∞ ¬ßlSYST√àME DE CO√õT EXPONENTIEL");
            lore.add("¬ß7‚îÇ ¬ß6Base: ¬ße" + NumberFormatter.format(totalInvested) + " tokens investis");
            lore.add("¬ß7‚îÇ ¬ß7Plus la pioche est endommag√©e, plus c'est cher");
            lore.add("¬ß7‚îÇ ¬ß7Tous les boutons = r√©paration maximale possible");
            lore.add("¬ß7‚îî");

        } else {
            lore.add("¬ßc‚ùå ¬ßlPIOCHE INTROUVABLE");
            lore.add("¬ß7‚îÇ ¬ß7Pioche l√©gendaire introuvable!");
            lore.add("¬ß7‚îÇ ¬ß7Assurez-vous qu'elle est dans votre inventaire.");
            lore.add("¬ß7‚îî");
        }

        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);
        item.setItemMeta(meta);

        return item;
    }

    /**
     * NOUVEAU : Classe pour stocker le r√©sultat de la r√©paration maximale
     */
    private record MaxRepairResult(int repairPoints, long cost, double repairPercent, double finalHealthPercent) {
    }
}