package fr.prisontycoon.events;

import fr.prisontycoon.PrisonTycoon;
import fr.prisontycoon.enchantments.WeaponArmorEnchantmentManager;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.PlayerDeathEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerItemDamageEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;

/**
 * Listener pour les enchantements d'√©p√©es et armures
 */
public class WeaponArmorEnchantmentListener implements Listener {

    private final PrisonTycoon plugin;

    public WeaponArmorEnchantmentListener(PrisonTycoon plugin) {
        this.plugin = plugin;
    }

    /**
     * G√®re l'ouverture du GUI d'enchantement avec Shift + Clic droit
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void onPlayerInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        ItemStack item = event.getItem();

        if (item == null || item.getType() == Material.AIR) return;

        // V√©rifie si c'est une √©p√©e ou une armure valide
        if (!isValidWeaponOrArmor(item)) return;

        // V√©rifie si c'est Shift + Clic droit
        if (!player.isSneaking()) return;

        if (event.getAction() != org.bukkit.event.block.Action.RIGHT_CLICK_AIR &&
                event.getAction() != org.bukkit.event.block.Action.RIGHT_CLICK_BLOCK) {
            return;
        }

        // √âvite d'ouvrir le menu si le joueur clique sur un bloc interactif
        if (event.getClickedBlock() != null && isInteractiveBlock(event.getClickedBlock().getType())) {
            return;
        }

        event.setCancelled(true);
        plugin.getWeaponArmorEnchantGUI().openEnchantMenu(player, item);
    }

    /**
     * G√®re les clics dans les GUIs d'enchantement
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void onInventoryClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player player)) return;

        String title = event.getView().getTitle();

        if (!title.contains("¬ßc‚öî ¬ßlEnchantement d'√âp√©e") &&
                !title.contains("¬ß9üõ° ¬ßlEnchantement d'Armure")) {
            return;
        }

        // NOUVEAU : Si clic dans l'inventaire du joueur avec un livre d'enchantement
        if (event.getClickedInventory() == player.getInventory()) {
            ItemStack clickedItem = event.getCurrentItem();
            if (isAnyEnchantmentBook(clickedItem)) {
                event.setCancelled(true);
                handleBookApplicationClick(player, clickedItem);
                return;
            }
            // Pour les autres items dans l'inventaire, on n'interf√®re pas
            return;
        }

        // Si clic dans le GUI d'enchantement
        if (event.getClickedInventory() != player.getInventory()) {
            event.setCancelled(true);
            ItemStack clickedItem = event.getCurrentItem();
            if (clickedItem != null && clickedItem.getType() != Material.AIR) {
                plugin.getWeaponArmorEnchantGUI().handleMenuClick(player, event.getSlot(), clickedItem, event.getClick());
            }
        }
    }

    /**
     * G√®re l'application d'un livre d'enchantement (unique ou legacy) sur un item.
     * VERSION CORRIG√âE ET UNIFI√âE
     */
    private void handleBookApplicationClick(Player player, ItemStack book) {
        ItemMeta bookMeta = book.getItemMeta();
        if (bookMeta == null) return;

        // --- √âtape 1: Extraire l'ID de l'enchantement de mani√®re unifi√©e ---
        String enchantId = null;
        NamespacedKey uniqueKey = new NamespacedKey(plugin, "unique_enchant_book");
        NamespacedKey legacyKey = new NamespacedKey(plugin, "enchant_book_id");

        if (bookMeta.getPersistentDataContainer().has(uniqueKey, PersistentDataType.STRING)) {
            enchantId = bookMeta.getPersistentDataContainer().get(uniqueKey, PersistentDataType.STRING);
        } else if (bookMeta.getPersistentDataContainer().has(legacyKey, PersistentDataType.STRING)) {
            enchantId = bookMeta.getPersistentDataContainer().get(legacyKey, PersistentDataType.STRING);
        }

        if (enchantId == null) {
            return;
        }

        // --- √âtape 2: V√©rifications de base ---
        WeaponArmorEnchantmentManager manager = plugin.getWeaponArmorEnchantmentManager();
        WeaponArmorEnchantmentManager.UniqueEnchantment enchant = manager.getEnchantment(enchantId);

        if (enchant == null) {
            player.sendMessage("¬ßcErreur: L'enchantement '" + enchantId + "' n'existe pas ou n'est plus support√©.");
            return;
        }

        ItemStack item = player.getInventory().getItemInMainHand();

        // --- √âtape 3: Logique d'application et messages ---
        if (!manager.isCompatible(enchantId, item)) {
            player.sendMessage("¬ßcCet enchantement n'est pas compatible avec cet item !");
            return;
        }

        boolean success = manager.addEnchantment(item, enchantId, 1);

        if (success) {
            // Logique de succ√®s (consommer le livre, son, message)
            book.setAmount(book.getAmount() - 1);
            int newLevel = manager.getEnchantmentLevel(item, enchantId);

            if (newLevel == 1) {
                player.sendMessage("¬ßa‚úÖ Enchantement ¬ße" + enchant.getName() + " ¬ßaappliqu√© !");
            } else {
                player.sendMessage("¬ßa‚úÖ Enchantement ¬ße" + enchant.getName() + " ¬ßaam√©lior√© au niveau " + newLevel + " !");
            }

            player.playSound(player.getLocation(), org.bukkit.Sound.BLOCK_ENCHANTMENT_TABLE_USE, 1.0f, 1.5f);
            plugin.getWeaponArmorEnchantGUI().openEnchantMenu(player, item); // Rafra√Æchir le GUI
        } else {
            // Logique d'√©chec (donner la bonne raison au joueur)
            int currentLevel = manager.getEnchantmentLevel(item, enchantId);

            if (currentLevel >= enchant.getMaxLevel()) {
                player.sendMessage("¬ßcCet enchantement est d√©j√† au niveau maximum ! (" + enchant.getMaxLevel() + ")");
            } else {
                // La seule autre raison d'√©chec est que le nombre max d'enchantements est atteint.
                int currentCount = manager.getUniqueEnchantmentCount(item);
                int maxCount = manager.getMaxEnchantments(item); // On utilise notre nouvelle m√©thode fiable
                player.sendMessage("¬ßcNombre maximum d'enchantements uniques atteint ! (" + maxCount + ")");
                player.sendMessage("¬ß7Votre item a d√©j√† " + currentCount + " enchantement(s) unique(s).");
            }
        }
    }

    /**
     * G√®re les d√©g√¢ts inflig√©s avec une √©p√©e enchant√©e
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (!(event.getDamager() instanceof Player attacker)) return;

        ItemStack weapon = attacker.getInventory().getItemInMainHand();
        if (weapon == null || weapon.getType() == Material.AIR) return;

        // Traite les enchantements d'√©p√©e
        plugin.getWeaponArmorEnchantmentManager().handleWeaponDamage(attacker, event.getEntity(), weapon);

        // Traite les enchantements d'armure de la victime
        if (event.getEntity() instanceof Player victim) {
            plugin.getWeaponArmorEnchantmentManager().handleArmorDamage(victim, attacker);
        }
    }

    /**
     * G√®re la mort des joueurs pour les enchantements sp√©ciaux
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void onPlayerDeath(PlayerDeathEvent event) {
        Player dead = event.getEntity();
        Player killer = dead.getKiller();

        if (killer != null) {
            // G√®re les effets de R√©percussion et Chasseur
            plugin.getWeaponArmorEnchantmentManager().handlePlayerDeath(dead, killer);
        }
    }

    /**
     * Emp√™che la perte de durabilit√© pour les items avec Incassable
     */
    @EventHandler(priority = EventPriority.HIGH)
    public void onItemDamage(PlayerItemDamageEvent event) {
        ItemStack item = event.getItem();

        // V√©rifie si l'item a l'enchantement Incassable
        if (plugin.getWeaponArmorEnchantmentManager().hasEnchantment(item, "incassable")) {
            event.setCancelled(true); // Annule la perte de durabilit√©
        }
    }

    // M√©thodes utilitaires

    /**
     * V√©rifie si l'item est une √©p√©e ou une armure valide
     */
    private boolean isValidWeaponOrArmor(ItemStack item) {
        Material type = item.getType();

        // √âp√©es
        if (type == Material.NETHERITE_SWORD || type == Material.DIAMOND_SWORD ||
                type == Material.IRON_SWORD || type == Material.GOLDEN_SWORD ||
                type == Material.STONE_SWORD || type == Material.WOODEN_SWORD) {
            return true;
        }

        // Armures
        String typeName = type.name();
        return typeName.endsWith("_HELMET") || typeName.endsWith("_CHESTPLATE") ||
                typeName.endsWith("_LEGGINGS") || typeName.endsWith("_BOOTS");
    }

    /**
     * V√©rifie si l'item est un livre d'enchantement unique (√©p√©e/armure)
     */
    private boolean isUniqueEnchantmentBook(ItemStack item) {
        if (item == null || item.getType() != Material.ENCHANTED_BOOK) return false;
        if (!item.hasItemMeta()) return false;

        return item.getItemMeta().getPersistentDataContainer().has(
                new NamespacedKey(plugin, "unique_enchant_book"), PersistentDataType.STRING);
    }

    /**
     * V√©rifie si l'item est un livre d'enchantement de pioche (existant)
     */
    private boolean isPickaxeEnchantmentBook(ItemStack item) {
        if (item == null || item.getType() != Material.ENCHANTED_BOOK) return false;
        if (!item.hasItemMeta()) return false;

        return item.getItemMeta().getPersistentDataContainer().has(
                new NamespacedKey(plugin, "enchant_book_id"), PersistentDataType.STRING);
    }

    /**
     * V√©rifie si c'est un livre d'enchantement (pioche OU √©p√©e/armure)
     */
    private boolean isAnyEnchantmentBook(ItemStack item) {
        return isUniqueEnchantmentBook(item) || isPickaxeEnchantmentBook(item);
    }

    /**
     * V√©rifie si un bloc est interactif (pour √©viter d'ouvrir le GUI dessus)
     */
    private boolean isInteractiveBlock(org.bukkit.Material material) {
        return switch (material) {
            case CHEST, TRAPPED_CHEST, ENDER_CHEST, BARREL,
                 CRAFTING_TABLE, FURNACE, BLAST_FURNACE, SMOKER,
                 BREWING_STAND, ENCHANTING_TABLE, ANVIL, CHIPPED_ANVIL, DAMAGED_ANVIL,
                 LEVER, STONE_BUTTON, OAK_BUTTON, SPRUCE_BUTTON, BIRCH_BUTTON,
                 JUNGLE_BUTTON, ACACIA_BUTTON, DARK_OAK_BUTTON, CRIMSON_BUTTON, WARPED_BUTTON,
                 OAK_DOOR, SPRUCE_DOOR, BIRCH_DOOR, JUNGLE_DOOR, ACACIA_DOOR, DARK_OAK_DOOR,
                 CRIMSON_DOOR, WARPED_DOOR, IRON_DOOR -> true;
            default -> false;
        };
    }
}