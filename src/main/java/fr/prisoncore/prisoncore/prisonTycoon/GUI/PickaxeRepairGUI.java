package fr.prisoncore.prisoncore.prisonTycoon.GUI;

import fr.prisoncore.prisoncore.prisonTycoon.PrisonTycoon;
import fr.prisoncore.prisoncore.prisonTycoon.data.PlayerData;
import fr.prisoncore.prisoncore.prisonTycoon.enchantments.CustomEnchantment;
import fr.prisoncore.prisoncore.prisonTycoon.utils.NumberFormatter;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Menu de r√©paration de la pioche l√©gendaire
 */
public class PickaxeRepairGUI {

    private final PrisonTycoon plugin;

    // Slots pour la barre de pourcentage de r√©paration (ligne du milieu)
    private static final int[] REPAIR_BAR_SLOTS = {11, 12, 13, 14, 15};
    private static final int PICKAXE_INFO_SLOT = 4;
    private static final int BACK_BUTTON_SLOT = 18;
    private static final int CONFIRM_REPAIR_SLOT = 26;

    public PickaxeRepairGUI(PrisonTycoon plugin) {
        this.plugin = plugin;
    }

    /**
     * Ouvre le menu de r√©paration de la pioche
     */
    public void openRepairGUI(Player player) {
        Inventory gui = Bukkit.createInventory(null, 27, "¬ßcüî® ¬ßlR√©paration de Pioche ¬ßcüî®");

        // Remplissage d√©coratif
        fillBorders(gui);

        // Informations de la pioche
        gui.setItem(PICKAXE_INFO_SLOT, createPickaxeInfoItem(player));

        // Barre de pourcentage de r√©paration
        createRepairPercentageBar(gui, player, 50); // 50% par d√©faut

        // Bouton retour
        gui.setItem(BACK_BUTTON_SLOT, createBackButton());

        // Bouton de confirmation (d√©sactiv√© par d√©faut)
        gui.setItem(CONFIRM_REPAIR_SLOT, createConfirmRepairButton(player, 50));

        player.openInventory(gui);
        player.playSound(player.getLocation(), Sound.UI_BUTTON_CLICK, 0.5f, 1.0f);
    }

    /**
     * G√®re les clics dans le menu de r√©paration
     */
    public void handleRepairMenuClick(Player player, int slot, ItemStack item) {
        if (slot == BACK_BUTTON_SLOT) {
            plugin.getMainMenuGUI().openEnchantmentMenu(player);
            return;
        }

        // V√©rifier si c'est un clic sur la barre de pourcentage
        for (int i = 0; i < REPAIR_BAR_SLOTS.length; i++) {
            if (slot == REPAIR_BAR_SLOTS[i]) {
                int percentage = (i + 1) * 20; // 20%, 40%, 60%, 80%, 100%
                updateRepairSelection(player, percentage);
                return;
            }
        }

        // Bouton de confirmation
        if (slot == CONFIRM_REPAIR_SLOT) {
            executeRepair(player, item);
        }
    }

    /**
     * Met √† jour la s√©lection de pourcentage de r√©paration
     */
    private void updateRepairSelection(Player player, int percentage) {
        Inventory gui = player.getOpenInventory().getTopInventory();

        // Met √† jour la barre de pourcentage
        createRepairPercentageBar(gui, player, percentage);

        // Met √† jour le bouton de confirmation
        gui.setItem(CONFIRM_REPAIR_SLOT, createConfirmRepairButton(player, percentage));

        player.playSound(player.getLocation(), Sound.UI_BUTTON_CLICK, 0.8f, 1.2f);
    }

    /**
     * Ex√©cute la r√©paration de la pioche
     */
    private void executeRepair(Player player, ItemStack confirmItem) {
        if (confirmItem == null || !confirmItem.hasItemMeta()) return;

        ItemMeta meta = confirmItem.getItemMeta();
        if (!meta.hasLore()) return;

        // Extrait le pourcentage depuis le lore du bouton de confirmation
        List<String> lore = meta.getLore();
        int percentage = 0;
        long cost = 0;

        for (String line : lore) {
            if (line.contains("R√©paration:")) {
                String percentStr = line.replaceAll("[^0-9]", "");
                if (!percentStr.isEmpty()) {
                    percentage = Integer.parseInt(percentStr);
                }
            }
            if (line.contains("Co√ªt:")) {
                String costStr = line.replaceAll("[^0-9]", "");
                if (!costStr.isEmpty()) {
                    cost = Long.parseLong(costStr);
                }
            }
        }

        if (percentage == 0 || cost == 0) {
            player.sendMessage("¬ßc‚ùå Erreur lors de la lecture des donn√©es de r√©paration!");
            return;
        }

        PlayerData playerData = plugin.getPlayerDataManager().getPlayerData(player.getUniqueId());

        // V√©rifier si le joueur a assez de tokens
        if (playerData.getTokens() < cost) {
            player.sendMessage("¬ßc‚ùå Vous n'avez pas assez de tokens pour cette r√©paration!");
            player.sendMessage("¬ß7Co√ªt: ¬ß6" + NumberFormatter.format(cost) + " tokens");
            player.sendMessage("¬ß7Disponible: ¬ßc" + NumberFormatter.format(playerData.getTokens()) + " tokens");
            player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_NO, 1.0f, 1.0f);
            return;
        }

        // Trouver la pioche du joueur
        ItemStack pickaxe = plugin.getPickaxeManager().findPlayerPickaxe(player);
        if (pickaxe == null) {
            player.sendMessage("¬ßc‚ùå Pioche l√©gendaire introuvable!");
            return;
        }

        // Calculer la nouvelle durabilit√©
        short currentDurability = pickaxe.getDurability();
        short maxDurability = pickaxe.getType().getMaxDurability();

        // Prendre en compte l'enchantement durabilit√©
        int durabilityLevel = playerData.getEnchantmentLevel("durability");
        double durabilityBonus = durabilityLevel * 10.0;
        int maxDurabilityWithBonus = (int) (maxDurability * (1.0 + durabilityBonus / 100.0));

        // Calculer la r√©paration
        int currentDamage = currentDurability;
        int repairAmount = (int) (maxDurabilityWithBonus * (percentage / 100.0));
        int newDurability = Math.max(0, currentDamage - repairAmount);

        // Appliquer la r√©paration
        pickaxe.setDurability((short) newDurability);

        // D√©duire les tokens
        playerData.removeTokens(cost);

        // Mettre √† jour la pioche
        plugin.getPickaxeManager().updatePlayerPickaxe(player);

        // Messages de succ√®s
        double repairedPercent = ((double) repairAmount / maxDurabilityWithBonus) * 100;
        player.sendMessage("¬ßa‚úÖ Pioche r√©par√©e avec succ√®s!");
        player.sendMessage("¬ß7R√©paration: ¬ßa+" + String.format("%.1f%%", repairedPercent) + " de durabilit√©");
        player.sendMessage("¬ß7Co√ªt: ¬ß6" + NumberFormatter.format(cost) + " tokens");
        player.sendMessage("¬ß7Tokens restants: ¬ße" + NumberFormatter.format(playerData.getTokens()));

        player.playSound(player.getLocation(), Sound.BLOCK_ANVIL_USE, 1.0f, 1.0f);
        player.closeInventory();

        plugin.getPluginLogger().info("¬ßa" + player.getName() + " a r√©par√© sa pioche de " +
                String.format("%.1f%%", repairedPercent) + " pour " + NumberFormatter.format(cost) + " tokens");
    }

    /**
     * Cr√©e l'item d'information de la pioche
     */
    private ItemStack createPickaxeInfoItem(Player player) {
        ItemStack pickaxe = plugin.getPickaxeManager().findPlayerPickaxe(player);
        PlayerData playerData = plugin.getPlayerDataManager().getPlayerData(player.getUniqueId());

        ItemStack item = new ItemStack(Material.NETHERITE_PICKAXE);
        ItemMeta meta = item.getItemMeta();

        meta.setDisplayName("¬ß6‚õèÔ∏è ¬ßl√âTAT DE VOTRE PIOCHE");

        List<String> lore = new ArrayList<>();
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        if (pickaxe != null) {
            short currentDurability = pickaxe.getDurability();
            short maxDurability = pickaxe.getType().getMaxDurability();

            // Prendre en compte l'enchantement durabilit√©
            int durabilityLevel = playerData.getEnchantmentLevel("durability");
            double durabilityBonus = durabilityLevel * 10.0;
            int maxDurabilityWithBonus = (int) (maxDurability * (1.0 + durabilityBonus / 100.0));

            double currentHealthPercent = ((double)(maxDurabilityWithBonus - currentDurability) / maxDurabilityWithBonus) * 100;

            lore.add("¬ßeüìä ¬ßlDURABILIT√â ACTUELLE");
            lore.add("¬ß7‚îÇ ¬ße√âtat: " + getDurabilityColor(currentHealthPercent) + String.format("%.1f%%", currentHealthPercent));
            lore.add("¬ß7‚îÇ ¬ßeDurabilit√©: ¬ß6" + (maxDurabilityWithBonus - currentDurability) + "¬ß7/¬ß6" + maxDurabilityWithBonus);

            if (durabilityLevel > 0) {
                lore.add("¬ß7‚îÇ ¬ßeBonus Solidit√©: ¬ßa+" + String.format("%.0f%%", durabilityBonus) + " ¬ß7(Niv." + durabilityLevel + ")");
            }

            lore.add("¬ß7‚îî " + getDurabilityStatus(currentHealthPercent));
            lore.add("");

            // Valeur totale investie
            long totalInvested = calculateTotalInvestedTokens(playerData);
            lore.add("¬ß6üí∞ ¬ßlVALEUR TOTALE INVESTIE");
            lore.add("¬ß7‚îÇ ¬ß6Tokens investis: ¬ße" + NumberFormatter.format(totalInvested));
            lore.add("¬ß7‚îî ¬ß7Base de calcul pour les co√ªts de r√©paration");

        } else {
            lore.add("¬ßc‚ùå Pioche l√©gendaire introuvable!");
            lore.add("¬ß7Vous devez avoir votre pioche l√©gendaire");
            lore.add("¬ß7dans l'inventaire pour la r√©parer.");
        }

        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);
        item.setItemMeta(meta);

        return item;
    }

    /**
     * Cr√©e la barre de s√©lection de pourcentage de r√©paration
     */
    private void createRepairPercentageBar(Inventory gui, Player player, int selectedPercentage) {
        for (int i = 0; i < REPAIR_BAR_SLOTS.length; i++) {
            int percentage = (i + 1) * 20; // 20%, 40%, 60%, 80%, 100%
            boolean isSelected = percentage == selectedPercentage;

            Material material;
            String color;
            if (isSelected) {
                material = Material.LIME_STAINED_GLASS;
                color = "¬ßa";
            } else if (percentage <= 40) {
                material = Material.YELLOW_STAINED_GLASS;
                color = "¬ße";
            } else if (percentage <= 80) {
                material = Material.ORANGE_STAINED_GLASS;
                color = "¬ß6";
            } else {
                material = Material.RED_STAINED_GLASS;
                color = "¬ßc";
            }

            ItemStack item = new ItemStack(material);
            ItemMeta meta = item.getItemMeta();

            meta.setDisplayName(color + "¬ßl" + percentage + "% ¬ß7de r√©paration");

            List<String> lore = new ArrayList<>();
            lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

            if (isSelected) {
                lore.add("¬ßa‚úÖ ¬ßlS√âLECTIONN√â");
                lore.add("¬ß7Cette option est actuellement s√©lectionn√©e");
            } else {
                lore.add("¬ß7R√©parer ¬ße" + percentage + "% ¬ß7de la durabilit√©");
                lore.add("¬ß7de votre pioche l√©gendaire");
            }

            // Calcul du co√ªt pour ce pourcentage
            PlayerData playerData = plugin.getPlayerDataManager().getPlayerData(player.getUniqueId());
            long totalInvested = calculateTotalInvestedTokens(playerData);
            long cost = calculateRepairCost(totalInvested, percentage);

            lore.add("¬ß7");
            lore.add("¬ß6üí∞ ¬ßlCO√õT DE R√âPARATION");
            lore.add("¬ß7‚îÇ ¬ß6Co√ªt: ¬ße" + NumberFormatter.format(cost) + " tokens");
            lore.add("¬ß7‚îÇ ¬ß7Base: ¬ß6" + NumberFormatter.format(totalInvested) + " tokens investis");
            lore.add("¬ß7‚îî ¬ß7Pourcentage: ¬ße" + getRepairCostPercentage(percentage) + "%");

            if (!isSelected) {
                lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
                lore.add("¬ße‚ú® Cliquez pour s√©lectionner!");
            }

            lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

            meta.setLore(lore);
            item.setItemMeta(meta);

            gui.setItem(REPAIR_BAR_SLOTS[i], item);
        }
    }

    /**
     * Cr√©e le bouton de confirmation de r√©paration
     */
    private ItemStack createConfirmRepairButton(Player player, int percentage) {
        PlayerData playerData = plugin.getPlayerDataManager().getPlayerData(player.getUniqueId());
        long totalInvested = calculateTotalInvestedTokens(playerData);
        long cost = calculateRepairCost(totalInvested, percentage);
        boolean canAfford = playerData.getTokens() >= cost;

        Material material = canAfford ? Material.EMERALD : Material.BARRIER;
        String color = canAfford ? "¬ßa" : "¬ßc";
        String icon = canAfford ? "‚úÖ" : "‚ùå";

        ItemStack item = new ItemStack(material);
        ItemMeta meta = item.getItemMeta();

        meta.setDisplayName(color + icon + " ¬ßlCONFIRMER LA R√âPARATION");

        List<String> lore = new ArrayList<>();
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        lore.add("¬ßeüî® ¬ßlR√âSUM√â DE LA R√âPARATION");
        lore.add("¬ß7‚îÇ ¬ßeR√©paration: ¬ßa" + percentage + "%");
        lore.add("¬ß7‚îÇ ¬ß6Co√ªt: ¬ße" + NumberFormatter.format(cost) + " tokens");
        lore.add("¬ß7‚îÇ ¬ßeDisponible: " + (canAfford ? "¬ßa" : "¬ßc") + NumberFormatter.format(playerData.getTokens()) + " tokens");

        if (canAfford) {
            long remaining = playerData.getTokens() - cost;
            lore.add("¬ß7‚îÇ ¬ßeRestant: ¬ßa" + NumberFormatter.format(remaining) + " tokens");
            lore.add("¬ß7‚îî");
            lore.add("");
            lore.add("¬ßa‚úÖ ¬ßlR√âPARATION POSSIBLE");
            lore.add("¬ß7Votre pioche sera r√©par√©e de ¬ßa" + percentage + "%");
            lore.add("¬ß7et vous conserverez ¬ßa" + NumberFormatter.format(remaining) + " tokens");
            lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
            lore.add("¬ßa‚ú® Cliquez pour confirmer!");
        } else {
            long missing = cost - playerData.getTokens();
            lore.add("¬ß7‚îÇ ¬ßcManquant: ¬ß4" + NumberFormatter.format(missing) + " tokens");
            lore.add("¬ß7‚îî");
            lore.add("");
            lore.add("¬ßc‚ùå ¬ßlTOKENS INSUFFISANTS");
            lore.add("¬ß7Vous devez obtenir ¬ßc" + NumberFormatter.format(missing));
            lore.add("¬ß7tokens suppl√©mentaires pour cette r√©paration.");
            lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
            lore.add("¬ß7Continuez √† miner pour plus de tokens!");
        }

        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);
        item.setItemMeta(meta);

        return item;
    }

    /**
     * Calcule le co√ªt total de tokens investis dans tous les enchantements
     */
    private long calculateTotalInvestedTokens(PlayerData playerData) {
        long totalCost = 0;

        Map<String, Integer> enchantments = playerData.getEnchantmentLevels();

        for (Map.Entry<String, Integer> entry : enchantments.entrySet()) {
            String enchantName = entry.getKey();
            int currentLevel = entry.getValue();

            CustomEnchantment enchantment = plugin.getEnchantmentManager().getEnchantment(enchantName);
            if (enchantment != null) {
                // Calcule le co√ªt total pour atteindre ce niveau
                for (int level = 1; level <= currentLevel; level++) {
                    totalCost += enchantment.getUpgradeCost(level);
                }
            }
        }

        return totalCost;
    }

    /**
     * Calcule le co√ªt de r√©paration bas√© sur un pourcentage de la valeur investie
     */
    private long calculateRepairCost(long totalInvested, int repairPercentage) {
        // Le co√ªt de r√©paration est un pourcentage de la valeur totale investie
        double costPercentage = getRepairCostPercentage(repairPercentage) / 100.0;
        return (long) (totalInvested * costPercentage);
    }

    /**
     * Retourne le pourcentage du co√ªt de r√©paration selon le pourcentage de r√©paration
     */
    private double getRepairCostPercentage(int repairPercentage) {
        // Co√ªt plus √©lev√© pour les r√©parations importantes
        return switch (repairPercentage) {
            case 20 -> 1.0;   // 1% de la valeur investie
            case 40 -> 2.5;   // 2.5% de la valeur investie
            case 60 -> 4.5;   // 4.5% de la valeur investie
            case 80 -> 7.0;   // 7% de la valeur investie
            case 100 -> 10.0; // 10% de la valeur investie
            default -> 1.0;
        };
    }

    /**
     * Retourne la couleur selon le pourcentage de durabilit√©
     */
    private String getDurabilityColor(double healthPercent) {
        if (healthPercent >= 75) return "¬ßa"; // Vert
        if (healthPercent >= 50) return "¬ße"; // Jaune
        if (healthPercent >= 25) return "¬ß6"; // Orange
        return "¬ßc"; // Rouge
    }

    /**
     * Retourne le statut de la durabilit√©
     */
    private String getDurabilityStatus(double healthPercent) {
        if (healthPercent >= 75) return "¬ßa‚úì Pioche en excellent √©tat";
        if (healthPercent >= 50) return "¬ße‚ö†Ô∏è Pioche en bon √©tat";
        if (healthPercent >= 25) return "¬ß6‚ö†Ô∏è Pioche us√©e, r√©paration recommand√©e";
        return "¬ßc‚ö†Ô∏è Pioche tr√®s endommag√©e, r√©paration urgente!";
    }

    /**
     * Cr√©e le bouton de retour
     */
    private ItemStack createBackButton() {
        ItemStack item = new ItemStack(Material.ARROW);
        ItemMeta meta = item.getItemMeta();

        meta.setDisplayName("¬ß7‚¨Ö ¬ßlRetour au Menu Principal");

        List<String> lore = new ArrayList<>();
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
        lore.add("¬ß7Retour au menu d'enchantements");
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
        lore.add("¬ße‚ú® Cliquez pour revenir!");
        lore.add("¬ß8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);
        item.setItemMeta(meta);

        return item;
    }

    /**
     * Remplit les bordures avec des items d√©coratifs
     */
    private void fillBorders(Inventory gui) {
        ItemStack filler = new ItemStack(Material.GRAY_STAINED_GLASS_PANE);
        ItemMeta meta = filler.getItemMeta();

        if (meta != null) {
            meta.setDisplayName("¬ß7");
            filler.setItemMeta(meta);
        }

        // Remplir les bordures (slots 0-8, 9, 17, 18-26)
        int[] borderSlots = {0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 16, 17, 19, 20, 21, 22, 23, 24, 25};

        for (int slot : borderSlots) {
            gui.setItem(slot, filler);
        }
    }
}