package fr.prisoncore.prisoncore.prisonTycoon.managers;

import fr.prisoncore.prisoncore.prisonTycoon.PrisonTycoon;
import fr.prisoncore.prisoncore.prisonTycoon.data.ContainerData;
import fr.prisoncore.prisoncore.prisonTycoon.utils.NumberFormatter;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.Sound;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.util.io.BukkitObjectInputStream;
import org.bukkit.util.io.BukkitObjectOutputStream;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;

/**
 * Gestionnaire des conteneurs - MODIFI√â pour conserver les m√©tadonn√©es
 */
public class ContainerManager {

    private final PrisonTycoon plugin;
    private final NamespacedKey containerKey;
    private final NamespacedKey containerTierKey;
    private final NamespacedKey containerDataKey;
    private final NamespacedKey containerUUIDKey; // NOUVEAU: Identifiant unique

    public ContainerManager(PrisonTycoon plugin) {
        this.plugin = plugin;
        this.containerKey = new NamespacedKey(plugin, "container");
        this.containerTierKey = new NamespacedKey(plugin, "container_tier");
        this.containerDataKey = new NamespacedKey(plugin, "container_data");
        this.containerUUIDKey = new NamespacedKey(plugin, "container_uuid"); // NOUVEAU

        plugin.getPluginLogger().info("¬ßaContainerManager initialis√©.");
    }

    /**
     * MODIFI√â : Cr√©e un nouvel item conteneur (non-stackable)
     */
    /**
     * CORRIG√â : Cr√©e un nouvel item conteneur avec UUID al√©atoire unique
     */
    public ItemStack createContainer(int tier) {
        if (tier < 1 || tier > 5) {
            throw new IllegalArgumentException("Tier doit √™tre entre 1 et 5");
        }

        ItemStack container = new ItemStack(Material.CHEST);
        ItemMeta meta = container.getItemMeta();

        // Nom du conteneur
        String tierName = getTierName(tier);
        meta.setDisplayName("¬ß6üì¶ Conteneur " + tierName);

        // CORRIG√â : UUID al√©atoire UNIQUE pour chaque conteneur
        String uniqueId = UUID.randomUUID().toString();

        // CORRIG√â : Utilise un hashCode bas√© sur l'UUID + timestamp pour garantir l'unicit√© absolue
        long timestamp = System.currentTimeMillis();
        int uniqueHash = (uniqueId + "_" + timestamp).hashCode();
        meta.setCustomModelData(Math.abs(uniqueHash % 1000000) + tier * 1000000); // Garantit l'unicit√© totale

        // Lore d√©taill√©
        List<String> lore = new ArrayList<>();
        ContainerData data = new ContainerData(tier);

        lore.add("¬ß7‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
        lore.add("¬ßeüìä Informations du conteneur:");
        lore.add("¬ß7‚îÉ Tier: ¬ß6" + tier + " ¬ß7(" + tierName + "¬ß7)");
        lore.add("¬ß7‚îÉ Capacit√©: ¬ßa" + NumberFormatter.format(data.getMaxCapacity()) + " items");
        lore.add("¬ß7‚îÉ Durabilit√©: ¬ß2" + data.getDurability() + "¬ß7/¬ß2" + data.getMaxDurability());
        lore.add("¬ß7‚îÉ √âtat: ¬ßaNeuf");
        lore.add("");
        lore.add("¬ße‚öôÔ∏è Fonctionnalit√©s:");
        lore.add("¬ß7‚îÉ Auto-collecte lors du minage");
        lore.add("¬ß7‚îÉ Syst√®me de filtres (whitelist)");
        lore.add("¬ß7‚îÉ Compatible avec ¬ß6/sell all");
        lore.add("¬ß7‚îÉ Ne peut pas √™tre pos√© au sol");
        lore.add("¬ß7‚îÉ ¬ßcNon-stackable");
        lore.add("");
        lore.add("¬ßeüéÆ Utilisation:");
        lore.add("¬ß7‚îÉ ¬ßaShift + Clic droit ¬ß7‚Üí Configuration");
        lore.add("¬ß7‚îÉ Gardez dans votre inventaire");
        lore.add("¬ß7‚îÉ Les blocs min√©s vont directement dedans");
        lore.add("");
        lore.add("¬ßeüìà Avantages du Tier " + tier + ":");
        switch (tier) {
            case 1 -> {
                lore.add("¬ß7‚îÉ Capacit√© de base (36 stacks)");
                lore.add("¬ß7‚îÉ Durabilit√© standard (50 utilisations)");
            }
            case 2 -> {
                lore.add("¬ß7‚îÉ Capacit√© doubl√©e (72 stacks)");
                lore.add("¬ß7‚îÉ Durabilit√© am√©lior√©e (100 utilisations)");
            }
            case 3 -> {
                lore.add("¬ß7‚îÉ Grande capacit√© (144 stacks)");
                lore.add("¬ß7‚îÉ Bonne durabilit√© (200 utilisations)");
            }
            case 4 -> {
                lore.add("¬ß7‚îÉ Tr√®s grande capacit√© (288 stacks)");
                lore.add("¬ß7‚îÉ Haute durabilit√© (400 utilisations)");
            }
            case 5 -> {
                lore.add("¬ß7‚îÉ Capacit√© maximale (576 stacks)");
                lore.add("¬ß7‚îÉ Durabilit√© maximale (800 utilisations)");
            }
        }
        lore.add("");
        lore.add("¬ßc‚ö†Ô∏è ¬ß7Se d√©grade √† chaque vente avec ¬ßc/sell all");
        lore.add("¬ß7‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);

        // CORRIG√â : Donn√©es persistantes avec UUID unique
        meta.getPersistentDataContainer().set(containerKey, PersistentDataType.BOOLEAN, true);
        meta.getPersistentDataContainer().set(containerTierKey, PersistentDataType.INTEGER, tier);
        meta.getPersistentDataContainer().set(containerUUIDKey, PersistentDataType.STRING, uniqueId);

        // Serialise les donn√©es du conteneur
        String serializedData = serializeContainerData(data);
        meta.getPersistentDataContainer().set(containerDataKey, PersistentDataType.STRING, serializedData);

        container.setItemMeta(meta);

        plugin.getPluginLogger().debug("Conteneur cr√©√© - Tier: " + tier + ", UUID: " + uniqueId + ", Hash: " + uniqueHash);

        return container;
    }

    /**
     * V√©rifie si un item est un conteneur
     */
    public boolean isContainer(ItemStack item) {
        if (item == null || !item.hasItemMeta()) return false;
        return item.getItemMeta().getPersistentDataContainer().has(containerKey, PersistentDataType.BOOLEAN);
    }

    /**
     * R√©cup√®re les donn√©es d'un conteneur depuis un item
     */
    public ContainerData getContainerData(ItemStack item) {
        if (!isContainer(item)) return null;

        ItemMeta meta = item.getItemMeta();
        String serializedData = meta.getPersistentDataContainer().get(containerDataKey, PersistentDataType.STRING);

        if (serializedData == null) {
            // Conteneur legacy, cr√©er des donn√©es par d√©faut
            int tier = meta.getPersistentDataContainer().getOrDefault(containerTierKey, PersistentDataType.INTEGER, 1);
            return new ContainerData(tier);
        }

        return deserializeContainerData(serializedData);
    }

    /**
     * R√©cup√®re tous les conteneurs d'un joueur
     */
    public List<ContainerData> getPlayerContainers(Player player) {
        List<ContainerData> containers = new ArrayList<>();

        for (ItemStack item : player.getInventory().getContents()) {
            if (isContainer(item)) {
                ContainerData data = getContainerData(item);
                if (data != null) {
                    containers.add(data);
                }
            }
        }

        return containers;
    }

    /**
     * MODIFI√â : Tente d'ajouter un item aux conteneurs du joueur (avec m√©tadonn√©es)
     */
    public boolean addItemToContainers(Player player, ItemStack itemToAdd) {
        if (itemToAdd == null || itemToAdd.getAmount() <= 0) return false;

        for (ItemStack item : player.getInventory().getContents()) {
            if (isContainer(item)) {
                ContainerData data = getContainerData(item);
                if (data != null && !data.isBroken()) {
                    if (data.addItem(itemToAdd)) {
                        // Met √† jour l'item dans l'inventaire
                        updateContainerItem(item, data);
                        return true;
                    }
                }
            }
        }

        return false; // Aucun conteneur disponible
    }

    /**
     * MODIFI√â : Vend le contenu de tous les conteneurs du joueur (seulement les items vendables)
     */
    public long sellAllContainerContents(Player player) {
        long totalValue = 0;
        int totalItems = 0;
        List<ContainerData> brokenContainers = new ArrayList<>();

        for (ItemStack item : player.getInventory().getContents()) {
            if (isContainer(item)) {
                ContainerData data = getContainerData(item);
                if (data != null && data.isSellEnabled() && !data.isBroken()) {

                    // NOUVEAU : Obtient seulement les items vendables
                    Map<ItemStack, Integer> vendableItems = data.getVendableContents(
                            material -> plugin.getConfigManager().getSellPrice(material)
                    );

                    // Calcule la valeur du contenu vendable
                    long containerValue = 0;
                    for (Map.Entry<ItemStack, Integer> entry : vendableItems.entrySet()) {
                        long price = plugin.getConfigManager().getSellPrice(entry.getKey().getType());
                        containerValue += price * entry.getValue();
                        totalItems += entry.getValue();
                    }

                    if (containerValue > 0) {
                        totalValue += containerValue;

                        // NOUVEAU : Vide seulement les items vendables
                        data.clearVendableContents(material -> plugin.getConfigManager().getSellPrice(material));

                        // Utilise la durabilit√©
                        if (!data.useDurability(1)) {
                            brokenContainers.add(data);
                        }

                        // Met √† jour l'item
                        updateContainerItem(item, data);
                    }
                }
            }
        }

        // Notifie des conteneurs cass√©s
        if (!brokenContainers.isEmpty()) {
            player.sendMessage("¬ßcüí• " + brokenContainers.size() + " conteneur(s) cass√©(s) lors de la vente!");
            player.playSound(player.getLocation(), Sound.ENTITY_ITEM_BREAK, 1.0f, 0.8f);
        }

        if (totalItems > 0) {
            player.sendMessage("¬ßa‚úÖ Contenu des conteneurs vendu: ¬ße" + NumberFormatter.format(totalItems) + " items ¬ß7pour ¬ß6" + NumberFormatter.format(totalValue) + " coins");
        }

        return totalValue;
    }

    /**
     * Nom du tier
     */
    private String getTierName(int tier) {
        return switch (tier) {
            case 1 -> "¬ß7Basique";
            case 2 -> "¬ßaStandard";
            case 3 -> "¬ßbAvanc√©";
            case 4 -> "¬ß5√âpique";
            case 5 -> "¬ß6L√©gendaire";
            default -> "¬ßfInconnu";
        };
    }

    /**
     * CORRIG√â : S√©rialise les donn√©es du conteneur avec version mise √† jour
     */
    private String serializeContainerData(ContainerData data) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            BukkitObjectOutputStream dataOutput = new BukkitObjectOutputStream(bos);

            dataOutput.writeInt(2); // Version 2 supporte les referenceItems

            // Donn√©es de base
            dataOutput.writeInt(data.getTier());
            dataOutput.writeInt(data.getDurability());
            dataOutput.writeBoolean(data.isSellEnabled());

            // Whitelist
            dataOutput.writeInt(data.getWhitelist().size());
            for (Material material : data.getWhitelist()) {
                dataOutput.writeUTF(material.name());
            }

            // Contents
            dataOutput.writeInt(data.getContents().size());
            for (Map.Entry<ItemStack, Integer> entry : data.getContents().entrySet()) {
                dataOutput.writeObject(entry.getKey());
                dataOutput.writeInt(entry.getValue());
            }

            Map<Integer, ItemStack> refs = data.getReferenceItems();
            dataOutput.writeInt(refs.size());
            for (Map.Entry<Integer, ItemStack> entry : refs.entrySet()) {
                dataOutput.writeInt(entry.getKey());      // √âcrit le slot (Integer)
                dataOutput.writeObject(entry.getValue()); // √âcrit l'item (ItemStack)
            }

            dataOutput.close();
            return Base64.getEncoder().encodeToString(bos.toByteArray());

        } catch (IOException e) {
            plugin.getPluginLogger().warning("Erreur s√©rialisation conteneur: " + e.getMessage());
            return "";
        }
    }

    /**
     * MODIFI√â: D√©s√©rialise les donn√©es du conteneur (avec items de r√©f√©rence)
     */
    private ContainerData deserializeContainerData(String serializedData) {
        try {
            byte[] data = Base64.getDecoder().decode(serializedData);
            ByteArrayInputStream bis = new ByteArrayInputStream(data);
            BukkitObjectInputStream dataInput = new BukkitObjectInputStream(bis);

            int version = dataInput.readInt();

            // Donn√©es de base
            int tier = dataInput.readInt();
            int durability = dataInput.readInt();
            boolean sellEnabled = dataInput.readBoolean();

            // Whitelist
            Set<Material> whitelist = new HashSet<>();
            int whitelistSize = dataInput.readInt();
            for (int i = 0; i < whitelistSize; i++) {
                try {
                    whitelist.add(Material.valueOf(dataInput.readUTF()));
                } catch (IllegalArgumentException ignored) {}
            }

            // Contents
            Map<ItemStack, Integer> contents = new LinkedHashMap<>();
            int contentsSize = dataInput.readInt();
            for (int i = 0; i < contentsSize; i++) {
                try {
                    ItemStack item = (ItemStack) dataInput.readObject();
                    int quantity = dataInput.readInt();
                    contents.put(item, quantity);
                } catch (Exception e) {
                    plugin.getPluginLogger().warning("Erreur lecture item conteneur: " + e.getMessage());
                }
            }

            Map<Integer, ItemStack> referenceItems = new HashMap<>();
            if (version >= 2) {
                int refItemsSize = dataInput.readInt();
                for (int i = 0; i < refItemsSize; i++) {
                    try {
                        int slot = dataInput.readInt();             // Lit le slot (Integer)
                        ItemStack refItem = (ItemStack) dataInput.readObject(); // Lit l'item (ItemStack)
                        referenceItems.put(slot, refItem);
                    } catch (Exception e) {
                        plugin.getPluginLogger().warning("Erreur lecture item r√©f√©rence: " + e.getMessage());
                    }
                }
            }

            dataInput.close();

            // Cr√©e les donn√©es avec les nouvelles informations
            ContainerData containerData = new ContainerData(tier, contents, whitelist, sellEnabled, durability);
            containerData.setReferenceItems(referenceItems);

            return containerData;

        } catch (Exception e) {
            plugin.getPluginLogger().warning("Erreur d√©s√©rialisation conteneur: " + e.getMessage());
            return null;
        }
    }
    /**
     * NOUVEAU : Obtient l'UUID unique d'un conteneur
     */
    public String getContainerUUID(ItemStack item) {
        if (!isContainer(item)) return null;

        ItemMeta meta = item.getItemMeta();
        return meta.getPersistentDataContainer().get(containerUUIDKey, PersistentDataType.STRING);
    }

    /**
     * RENFORC√â : Trouve un conteneur sp√©cifique par UUID dans l'inventaire
     */
    public ItemStack findContainerByUUID(Player player, String uuid) {
        if (uuid == null || player == null) return null;

        for (ItemStack item : player.getInventory().getContents()) {
            if (item != null && isContainer(item)) {
                String containerUUID = getContainerUUID(item);
                if (uuid.equals(containerUUID)) {
                    return item;
                }
            }
        }
        return null;
    }

    /**
     * NOUVEAU : M√©thode pour mettre √† jour un conteneur sp√©cifique dans l'inventaire
     */
    public boolean updateContainerInInventory(Player player, String uuid, ContainerData newData) {
        if (uuid == null || player == null || newData == null) return false;

        for (int i = 0; i < player.getInventory().getSize(); i++) {
            ItemStack item = player.getInventory().getItem(i);
            if (item != null && isContainer(item)) {
                String containerUUID = getContainerUUID(item);
                if (uuid.equals(containerUUID)) {
                    updateContainerItem(item, newData);
                    player.getInventory().setItem(i, item); // Force la mise √† jour
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * NOUVEAU : Transf√®re le contenu d'un conteneur vers l'inventaire du joueur
     */
    public int transferContainerToPlayer(Player player, ContainerData data) {
        if (player == null || data == null) return 0;

        int totalTransferred = 0;
        // Utiliser une copie pour √©viter ConcurrentModificationException lors de la suppression
        var contents = new HashMap<>(data.getContents());

        for (var entry : contents.entrySet()) {
            ItemStack itemKey = entry.getKey(); // L'ItemStack qui sert de cl√©
            Material material = itemKey.getType();
            int amount = entry.getValue();

            int amountToRemoveFromContainer = 0; // Quantit√© √† retirer du conteneur

            while (amount > 0) {
                int stackSize = Math.min(amount, material.getMaxStackSize());

                // On utilise l'itemKey clon√© pour l'ajout, afin de pr√©server les m√©tadonn√©es
                ItemStack itemToAdd = itemKey.clone();
                itemToAdd.setAmount(stackSize);

                // Essaie d'ajouter l'item √† l'inventaire
                var leftover = player.getInventory().addItem(itemToAdd);

                if (leftover.isEmpty()) {
                    // Tout le stack a √©t√© ajout√©
                    totalTransferred += stackSize;
                    amountToRemoveFromContainer += stackSize;
                    amount -= stackSize;
                } else {
                    // L'inventaire est plein, on calcule ce qui a √©t√© ajout√©
                    int addedAmount = stackSize - leftover.get(0).getAmount();
                    if (addedAmount > 0) {
                        totalTransferred += addedAmount;
                        amountToRemoveFromContainer += addedAmount;
                    }
                    // L'inventaire est plein, on arr√™te
                    break;
                }
            }

            // Met √† jour le conteneur APRES la boucle pour cet item
            if (amountToRemoveFromContainer > 0) {
                data.removeItem(itemKey, amountToRemoveFromContainer);
            }

            if (player.getInventory().firstEmpty() == -1) {
                // L'inventaire est plein, inutile de continuer la boucle principale
                break;
            }
        }

        return totalTransferred;
    }

    /**
     * MODIFI√â : Met √† jour un item conteneur avec de nouvelles donn√©es
     */
    public void updateContainerItem(ItemStack container, ContainerData data) {
        if (!isContainer(container) || data == null) return;

        ItemMeta meta = container.getItemMeta();
        if (meta == null) return;

        // Met √† jour la lore avec les nouvelles informations
        List<String> lore = new ArrayList<>();
        lore.add("¬ß7‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
        lore.add("¬ßeüìä Informations du conteneur:");
        lore.add("¬ß7‚îÉ Tier: ¬ß6" + data.getTier() + " ¬ß7(" + getTierName(data.getTier()) + "¬ß7)");
        lore.add("¬ß7‚îÉ Capacit√©: ¬ßa" + NumberFormatter.format(data.getMaxCapacity()) + " items");

        if (data.isBroken()) {
            lore.add("¬ß7‚îÉ Durabilit√©: ¬ßc0¬ß7/¬ß7" + data.getMaxDurability());
            lore.add("¬ß7‚îÉ √âtat: ¬ßcüí• CASS√â");
            meta.setDisplayName("¬ßcüí• Conteneur Cass√© - " + getTierName(data.getTier()));
        } else {
            lore.add("¬ß7‚îÉ Durabilit√©: ¬ß2" + data.getDurability() + "¬ß7/¬ß2" + data.getMaxDurability());
            double percentage = (double) data.getDurability() / data.getMaxDurability() * 100;
            lore.add("¬ß7‚îÉ √âtat: ¬ßa" + String.format("%.1f", percentage) + "%");
            meta.setDisplayName("¬ß6üì¶ Conteneur " + getTierName(data.getTier()));
        }

        lore.add("");
        lore.add("¬ßeüì¶ Contenu actuel:");

        if (data.getTotalItems() == 0) {
            lore.add("¬ß7‚îÉ Vide");
        } else {
            lore.add("¬ß7‚îÉ Items: ¬ßa" + NumberFormatter.format(data.getTotalItems()) +
                    "¬ß7/¬ßa" + NumberFormatter.format(data.getMaxCapacity()));
            double fillPercentage = (double) data.getTotalItems() / data.getMaxCapacity() * 100;
            lore.add("¬ß7‚îÉ Remplissage: ¬ßd" + String.format("%.1f", fillPercentage) + "%");
        }

        lore.add("");
        lore.add("¬ßeüéØ Filtres:");

        if (data.getWhitelist().isEmpty()) {
            lore.add("¬ß7‚îÉ Accepte tous les items");
        } else {
            lore.add("¬ß7‚îÉ ¬ßa" + data.getWhitelist().size() + " mat√©riaux filtr√©s");
        }

        lore.add("");
        lore.add("¬ßeüí∞ Vente automatique:");

        if (data.isBroken()) {
            lore.add("¬ß7‚îÉ ¬ß8Indisponible");
        } else {
            lore.add("¬ß7‚îÉ " + (data.isSellEnabled() ? "¬ßa‚úÖ Activ√©e" : "¬ßc‚ùå D√©sactiv√©e"));
        }

        lore.add("¬ß7‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");
        lore.add("¬ße‚öôÔ∏è ¬ßaShift + Clic droit ¬ß7pour configurer");
        lore.add("¬ß7‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨");

        meta.setLore(lore);

        // S√©rialise et sauvegarde les nouvelles donn√©es
        String serializedData = serializeContainerData(data);
        meta.getPersistentDataContainer().set(containerDataKey, PersistentDataType.STRING, serializedData);

        container.setItemMeta(meta);
    }
}